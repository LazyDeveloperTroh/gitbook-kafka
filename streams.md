---
description: >-
  토픽에 적재된 데이터를 실시간으로 변환하여 다른 토픽에 적재하는 라이브러리이다. 스트림즈 어플리케이션은 일반적으로 주로 스트림즈 DSL 을
  이용하여 개발하고 상황에 따라 프로세스 API 를 이용하여 개발한다.
---

# 카프카 스트림즈

### 카프카 스트림즈 장점 & 단점

* 스트림즈 애플리케이션 또는 카프카 브로커에 장애가 발생하더라도 정확히 한번만 처리할 수 있도록 구현되어 있어 데이터 처리 안정성이 뛰어나다. 컨슈머와 스트림즈 조합만으로 구현하기는 어렵다.
* 소스 토픽(사용하는 토픽)과 싱크 토픽(저장하는 토픽)의 카프카 클러스터가 다른 경우는 카프카 스트림즈가 지원하지 않음



### 스트림즈 내부 구조

스트림즈 애플리케이션은 내부적으로 스레드를 1개 이상 생성할 수 있으며, 스레드는 1개 이상의 태스크를 가진다. 스트림즈의 태스크는 스트림즈 애플리케이션을 실행하면 생기는 데이터 처리 최소 단위이다.  (파티션과 태스크는 일대일로 매칭된다)



#### 프로세서와 스트림

카프카 스트림즈에서는 트리 구조의 토폴로지를 통해 데이터를 스트림으로 처리한다. 토폴로지를 이루는 노드를 프로세서라고 부르고 노드와 노드를 이은 선을 스트림이라고 한다. 프로세서에는 소스 프로세서, 스트림 프로세서, 싱크 프로세서가 있다.

* 소스 프로세서 - 하나 이상의 토픽에서 데이터를 가져오는 역할을 한다
* 스트림 프로세서 - 다른 프로세서가 반환한 데이터를 처리(변환 or 분기)하는 역할을 한다.
* 싱크 프로세서 - 특정 토픽으로 저장하는 역할을 한다.



### 스트림즈 DSL

스트림즈 DSL에는 레코드의 흐름을 추상화한 3가지 개념인 KStream, KTable, GlobalKTable이 있다.



#### KStream

레코드의 흐름을 표현한 것으로 메세지 키와 메세지 값으로 구성되어 있다. KStream 으로 데이터를 조회하면 토픽에 존재하는 모든 레코드가 출력된다. = 토픽을 구독하는 것과 동일한 선상에서 사용하는 것



#### KTable

KStream과 다르게 메세지 키를 기준으로 묶어서 사용한다. KStream은 토픽의 모든 레코드를 조회할 수 있지만 KTable은 유니크한 메시지 키를 기준으로 가장 최신 레코드를 사용한다.



#### 코파티셔닝

KStream과 KTable 데이터를 조인하기 위해서는 반드시 코파티셔닝이 되어 있어야 한다. 코파티셔닝이란 조인을 하는 2개 토픽의 파티션 개수가 동일하고 파티셔닝 전략이 동일한 상태이다. 즉 코파티셔닝 상태라면 동일한 메세지 키를 가진 데이터가 동일한 태스크에 들어가는 것을 보장하게 된다.



#### GlobalKTable

코파티셔닝이 되지 않은 KStream과 KTable을 조인해서 사용하고 싶다면 KTable을 GlobalKTable로 선언하여 사용하면 된다. GlobalKTable은 코파티셔닝되지 않은 KStream과 조인할 수 있다. 왜냐하면  GlobalKTable은KTable과 다르게 뷰(?)를 통해 스트림즈 애플리케이션의 모든 태스크에서 공유되어 사용되기 때문이다. 하지만 GlobalKTable의 토픽이 엄청나게 많은 데이터가 많은 경우라면 스트림즈 애플리케이션에 부담이 될 수 있는 문제가 있다.



### 스트림즈 DSL 옵션

#### 주요 옵션(필수 옵션)

* bootstrap.servers - 프로듀서가 데이터를 전송할 브로커의 호스트 이름:포트를 1개 이상 작성한다.
* application.id - 스트림즈 애플리케이션을 구분하기 위한 고유한 아이디를 설정 = 컨슈머 그룹(group.id)

#### 주요 옵션(선택 옵션)

* default.key.serde -  레코드의 메세지 키를 직렬화, 역직렬화하는 클래스를 지정
* default.kvalue.serde - 레코드의 메세지 값을 직렬화, 역직렬화하는 클래스를 지정
* num.stream.threads - 스트림 프로세싱 실행 시 실행될 스레드 개수를 지정. default 1
* state.dir - 상태 기반 데이터 처리를 할 때 데이터를 저장할 디렉토리를 지정
