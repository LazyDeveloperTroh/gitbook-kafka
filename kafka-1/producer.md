# 프로듀서

#### 프로듀서란?

프로듀서는카프카에 필요한 데이터를 선언하고 특정 토픽의 파티션에 데이터를 전송하는 역할을 하며 <mark style="background-color:green;">**데이터를 전송할 때 리더 파티션을 가지고 있는 브로커와 통신한다.**</mark>**  프**로듀서는 데이터를 전송할 때 내부적으로 파티셔너, 배치 생성 단계를 거친다.&#x20;



#### 프로듀서 내부 구조

프로듀서의 내부 구조는 ProducerRecord, Partitioner, Accumulator, Sender로 구성된다. send() 메서드를 통해 레코드를 파티션으로 전송할 수 있는데 내부적으로 Partitioner에 의해 파티션 목적지가 정해지고 Accumerator에 의해 버퍼에 모았다가 한번에 데이터를 파티션으로 전송하여 처리량을 향상시킨다.

* ProducerRecord는 프로듀서에서 생성하는 레코드로 토픽에 보낼 데이터를 의미하며 토픽 정보, 파티션 정보, 타임스탬프, 메세지 키, 메세지 값이 포함되지만 <mark style="background-color:red;">**오프셋 정보는 포함되지 않고 오프셋은 파티션에 레코드가 저장되는 시점에 지정된다.**</mark>
* Partitioner는 어느 파티션으로 전송할지 지정하는 역할을 하고 메세지 키에 따라서 어느 파티션으로 전송할지 결정한다. 이를 통해 <mark style="background-color:red;">**통일한 키를 가지는 레코드라면 특정 파티션에 대해서 순서를 보장**</mark>할 수 있다.
* Accumulator는 배치로 묶어 전송할 데이터를 모으는 역할을 한다. send() 메서드를 호출할 때마다 파티션으로 데이터를 보내게 되면 네트워크 비용이 너무 많이 들기 때문에 <mark style="background-color:red;">**버퍼로 처리하여 처리량을 늘릴 수 있다**</mark>.



#### 파티셔너(Partitioner)

<mark style="background-color:green;">**Partitioner는 레코드를 어떤 파티션에 저장해야 하는지 결정하는 역할**</mark>을 하며 카프카 클라이언트 라이브러리 2.5.0 기준에서 UniformStickPartitioner와 RoundRobinPartition 2개의 파티셔너를 제공하며 <mark style="background-color:red;">**각 파티셔너는 메시지 키가 있을 경우와 없을 경우에 따라 동작을 다르게 한다.**</mark>\


* 메세지 키가 있는 경우?  둘 다 <mark style="background-color:red;">**메세지 키의 해시값과 파티션을 매칭하는 방식으로 동작하기 때문에 메시지 키가 동일하다면 동일한 파티션 번호에 전달된다**</mark>. <mark style="background-color:red;">**하지만 파티션 개수가 변경되는 경우 메세지 키와 파티션 번호 매칭이 깨지게 되는 문제가 발생**</mark>할 수 있기 때문에 파티션을 여유롭게 운영하는 것이 좋다.
* 메세지 키가 없는 경우?  각 파티셔너 모두 파티션에 최대한 동일하게 분배하는 로직이 들어있지만 **UniformStickyPartitioner는 RoundRobinPartitioner의 단점을 개선했다**. **RoundRobinPartitioner**는 ProducerRecord가 들어오는 대로 파티션을 순회하면서 전송하기 때문에 Accumulator에서 묶이는 정도가 적었기 때문에 전송 성능이 낮았다. 하지만 **UniformStickyPartitioner**는 Accumulator에서 레코드들이 배치로 묶일 때까지 기다렸다가 전송했기 때문에 전송 성능을 개선했다.



#### 프로듀서  주요 옵션(필수 옵션)

* bootstrap.servers = 프로듀서가 데이터를 전송할 대상 브로커의 호스트 이름:포트를 1개 이상 작성한다. 2개 이상 브로커 정보를 입력하여 일부 브로커에 이슈가 발생하더라도 이슈가 없도록 설정이 가능하다.
* key.serializer = 레코드를 전송하기 위해서는 직렬화가 필요하다. 이 때 레코드의 메세지 키를 직렬화하는 클래스를 지정한다.
* value.serializer = 레코드를 전송하기 위해서는 직렬화가 필요하다. 이 때 레코드의 메세지 값를 직렬화하는 클래스를 지정한다.



#### 프로듀서 주요 옵션(선택 옵션)

* acks - 프로듀서가 전송한 데이터가 브로커들에 정상적으로 저장되었는지 전송 성공 여부를 확인하는데 사용되는 옵션이다. 0, 1, -1(all) 중 하나로 선택할 수 있으며 기본 값은 1이다.
* linger.ms - 배치를 파티션에 전송하기 전까지 기다리는 시간으로 기본 값은 0이다. 브로커에 부담을 줄이기 위한 옵션이다.
* retries - 브로커로부터 에러를 받고 난 뒤 재 전송을 시도하는 횟수를 지정한다. 기본 값은 2147483647이다.
* max.in.flight.requests.per.connection - sender를 통해 파티션에 데이터를 보낼 때 최대 커넥션의 개수이다. 기본 값은 5로 데이터 처리량이 많아지는 경우 설정을 올리는 것도 좋은 방법이 될 수 있다.
* partitioner.class - 파티셔너 클래스를 지정한다.
* enable.idempotence - 멱등성 프로듀서로 동작할 지 여부. 카프카 2.5.5 는 기본 값 false, 3.0 부터는 true
* transactional.id - 레코드를 전송할 때 레코드를 트랜잭션 단위로 묶을지 여부를 설정한다. 기본 값은 null 이다.



#### ISR (In-Sync-Recplicas) 와 acks 옵션

<mark style="background-color:green;">**ISR은 리더 파티션과 팔로워 파티션의 데이터 동기화에 대한 개념이다.**</mark> 프로듀서가 리더 파티션에 데이터를 적재한 후 팔로워 파티션에서 <mark style="background-color:red;">**리더 파티션의 데이터를 복제하는 데에 시간이 걸리기 때문에 발생하는데 이때 파티션과 팔로워 파티션 간의 오프셋 차이가 발생하게 된다.**</mark>\
\
<mark style="background-color:green;">**acks 옵션은 프로듀서가 저장한 데이터가 카프카 클러스터에 얼마나 신뢰성 높게 저장할 지 지정할 수 있다.**</mark>

* acks 0 - 프로듀서가 리더 파티션으로 데이터를 전송했을 때 데이터가 저장되었는지 확인하지 않는 옵션이다. 즉 데이터 유실을 감안하고 성능을 최우선으로 고려할 때 사용할 수 있는 옵션이다.
* acks 1 - 프로듀서가 보낸 데이터가 리더 파티션에만 정상적으로 적재되었는지 확인하는 옵션이다. 만약 리더 파티션에 정상적으로 적재되지 않는다면 적재가 될 때까지 재시도할 수 있다. 그러나 리더 파티션에 적재되더라도 데이터 유실의 가능성은 존재한다. 리더 파티션에 적재 이후 팔로워 파티션에서 동기화 하기 이전에 리더 파티션이 있는 브로커에 장애가 발생한다면 동기화 되지 못한 데이터는 유실되기 때문이다.
* acks -1 (all) - 프로듀서가 보낸 데이터가 리더 파티션과 팔로워 파티션에 모두 정상적으로 적재되었는지 확인하는 옵션이다. 즉 성능보다는 신뢰도를 우선으로 한다. 모든 팔로워 파티션에 대해 신뢰성을 보장하는 것이 아니라 min.insync.replicas 에 설정한 브로커 수만큼만 신뢰성을 보장한다. 만약 해당 옵션이 2이고 브로커가 100대라면 브로커 2대에 대해서 데이터 적재 신뢰성을 보장한다는 의미이다.



### 멱등성 프로듀서

멱등성 프로듀서란 동일한 데이터를 여러 번 전송하더라도 카프카 클러스터에 단 한번만 저장되는 의미한다. 기본 프로듀서의 동작 방식은 적어도 한번 전달하는 방식이기 때문에 한번 이상 즉, 두 번 이상 적재할 가능성이 있으므로 데이터의 중복이 발생할 수 있다.\
\
enable.idempotence 옵션을 true로 설정하여 멱등성을 이용할 수 있다. 카프카 3.0.0 부터는 해당 옵션의 default 값이 true이다.



#### 멱등성 프로듀서의 동작

기본 프로듀서와 다르게 데이터를 브로커로 전달할 때 프로듀서 PID(Producer Unique ID)와 시퀀스 넘버(Sequence Number)를 함께 전달해야 한다. 그러면 브로커는 프로듀서의 PID와 시퀀스 넘버를 확인하여 동일한 메세지의 적재 요청이 오더라도 단 한번만 데이터를 적재시킬 수 있다. 즉 브로커로 여러 번 데이터를 전송하지만 브로커 내부에서 단 한번만 데이터를 적재하는 것이기 때문에 네트워크에 대한 부하가 발생할 수 있다.



#### 멱등성 프로듀서의 한계

멱등성 프로듀서는 동일한 세션에서만 한번 전달을 보장한다. 프로듀서 어플리케이션에 이슈가 발생하여 재시작하게 되면 PID가 달라지게 때문에 이후에 동일한 데이터에 대해 멱등성을 보장할 수 없게 된다.

