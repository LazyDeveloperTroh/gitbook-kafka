# 컨슈머

#### 컨슈머란?

브로커에 적재된 데이터를 가져와서 필요한 처리를 수행하는 역할을 한다.



#### 컨슈머 내부구조

* Fetcher - 리더 파티션으로부터 레코드들을 미리 가져와서 대기한다. poll() 메서드를 호출하기 전에 데이터를 미리 대기하고 있는 상태이다.
* poll() - Fetcher에 있는 레코드들을 리턴하는 메소드이다.
* ConsumerRecords - 처리하고자 하는 레코드들의 모음이다. 오프셋이 포함되어 있다.



#### 컨슈머 그룹

컨슈머를 그룹으로 격리된 환경에서 운영하는 방법이다. 컨슈머 그룹으로 묶인 컨슈머들은 토픽의 1개 이상의 파티션들에 할당되어 데이터를 가져갈 수 있다.\
\
하나의 파티션은 하나의 컨슈머에만 할당될 수 있기 때문에 일대일 매핑 관계에서 최대의 성능을 만들 수 있다. 만약 컨슈머의 개수가 파티션의 개수보다 많다면 해당 컨슈머는 파티션을 할당받지 못하고 유휴 상태로 남게된다.



#### 컨슈머 그룹을 왜 사용해야 해?

컨슈머가 그룹이 없는 경우 순서대로 작업을 해야하는 파이프 라인의 중간 작업에서 장애가 발생하는 경우 전체 작업이 중지되거나 장애가 해결될 때까지 이후 작업을 대기해야 하는 문제가 생긴다. 하지만 카프카의 컨슈머 그룹을 이용하면 토픽의 데이터를 작업 주제에 맞게 컨슈머 그룹을 만들어 운영할 수 있다. 컨슈머 그룹을 통해 운영하는 경우 일부 그룹에서 장애가 발생하더라도 그 외에 그룹은 정상적으로 동작할 것이고 장애가 발생한 그룹 역시 장애가 복구된 후 정상 처리가 되는 장점이 있다.



#### 리밸런싱

컨슈머 그룹을 구성하는 컨슈머들 중 일부 컨슈머에 장애가 발생하면 장애가 발생한 컨슈머에 할당된 파티션은 장애가 발생하지 않은 컨슈머에 소유권이 넘어가는데 이러한 과정을 리밸런싱이라고 한다. 리벌랜싱은 컨슈머가 추가되는 상황과 컨슈머가 제외되는 상황에서 발생한다.



#### 커밋

컨슈머는 카프카 브로커로부터 데이터를 어디까지 가져갔는지 커밋을 통해 기록한다. 이러한 기록은 브로커 내부에서 사용하는 토픽(\_\_consumer\_offsets)에 기록된다.



#### Assigner

컨슈머와 파티션 할당을 담당한다.&#x20;

* RangeAssignor - 각 토픽에서 파티션을 숫자로 정렬, 컨슈머를 사전 순서로 정렬하여 할당
* RoundRobinAssingor - 모든 파티션을 컨슈머에서 번갈아가면서 할당
* StickyAssignor - 최대한 파티션을 균등하게 배분하면서 할당



#### 컨슈머 주요 옵션(필수옵션)

* bootstrap.servers - 컨슈머가 데이터를 처리할 대상 카프카 클러스터에 속한 브로커의 호스트 이름:포트를 1개 이상 작성한다.
* key.deserializer - 레코드의 메세지 키를 역직렬화하는 클래스를 지정한다.
* value.deserializer - 레코드의 메세지 값을 역직렬화하는 클래스를 지정한다.



#### 컨슈머 주요 옵션(선택 옵션)

* group.id - 컨슈머 그룹 아이디를 지정한다. subscribe() 메서드로 토픽을 구독하여 사용할 때는 필수 옵션이고 기본 값은 null 이다.
* auto.offset.reset - 저장된 컨슈머 오프셋이 없는 경우(커밋 이력 없음) 어느 오프셋부터 읽을지 선택하는 옵션으로. latest, earliest, none 중 1개를 설정할 수 있다. 이미 컨슈머 오프셋이 있다면 이 옵션 값은 무시된다.
* enable.auto.commit - 자동 커밋으로 할지 수동 커밋으로 할지 선택한다. 기본 값은 true
* auto.commit.interval.ms - 자동 커밋일 경우 오프셋 커밋 간격을 지정한다. 기본 값은 5000(5초)
* max.poll.records - poll() 메서드를 통해 반환되는 레코드 개수를 지정한다. 기본 값은 500
* session.timeout.ms - 컨슈머가 브로커와 연결이 끊기는 최대 시간. 기본 값은 10000(10초).&#x20;
* hearbeat.interval.ms - 하트비트를 전송하는 시간 간격. 기본 값은 3000(3초). 즉 컨슈머가 브로커에게 하트비트를 보내고 session.timeout.ms 설정 시간만큼 다음 하트비트를 보내지 않는다면 컨슈머에게 이상이 있다고 판단한다.
* max.poll.interval.ms - poll() 메서드를 호출하는 간격의 최대 시간. 기본 값은 300000(5분)
* isolation.level - 트랜잭션 프로듀서가 레코드를 트랜잭션 단위로 보낼 경우 사용



